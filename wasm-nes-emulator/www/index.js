import { CPU } from "wasm-nes-emulator";
import { memory } from "wasm-nes-emulator/wasm_nes_emulator_bg";
const CELL_SIZE = 16; // px

//CHECK FOR NEED SCREEN UPDATE -

const COLORS = [
  "#000000", // Black
  "#FFFFFF", // White
  "#FF0000", // Red
  "#00FFFF", // Cyan
  "#800080", // Purple
  "#008000", // Green
  "#0000FF", // Blue
  "#FFFF00", // Yellow
  "#FFA500", // Orange
  "#A52A2A", // Brown
  "#FF9999", // Light red
  "#A9A9A9", // Dark grey
  "#808080", // Grey
  "#90EE90", // Light green
  "#ADD8E6", // Light blue
  "#D3D3D3", // Light grey
];
let cpu = CPU.new();

let game_code = [
  0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60,
  0xa9, 0x02, 0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9,
  0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13,
  0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe, 0x29, 0x03, 0x18, 0x69,
  0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3, 0x06,
  0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5,
  0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b,
  0xc9, 0x61, 0xf0, 0x22, 0x60, 0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01,
  0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02,
  0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9,
  0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94,
  0x06, 0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01,
  0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2,
  0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09,
  0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c, 0x35, 0x07, 0x60,
  0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
  0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5,
  0x10, 0x38, 0xe9, 0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01,
  0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6, 0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f,
  0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0, 0x01, 0x60, 0xe6, 0x11,
  0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29, 0x1f,
  0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91,
  0x00, 0x60, 0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81,
  0x10, 0x60, 0xa2, 0x00, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
];

cpu.load_pro(game_code);

const canvas = document.getElementById("canvas");
canvas.height = CELL_SIZE * 32;
canvas.width = CELL_SIZE * 32;

const ctx = canvas.getContext("2d");

document.getElementById("reset").addEventListener("click", (event) => {
  cpu = CPU.new();
  cpu.load_pro(game_code);
  drawPixel();
  renderLoop();
});

addEventListener("keypress", (event) => {
  cpu.mem_write(0xff, event.keyCode);
  const memPtr = cpu.mem_ptr();
});

let not_one = false;
let over_2 = false;
const renderLoop = () => {
  while (cpu.update == false) {
    cpu.mem_write(0xfe, Math.floor(Math.random() * 16) + 1);
    cpu.next();
    if (cpu.register_x > 2) {
      over_2 = true;
    }
  }
  drawPixel();
  cpu.reset_update();

  setTimeout(requestAnimationFrame(renderLoop), 0.7);
};

const drawPixel = () => {
  const memPtr = cpu.mem_ptr();
  const pixels = new Uint8Array(memory.buffer, memPtr, 0xffff);

  ctx.beginPath();
  for (let i = 0x0200; i <= 0x05ff; i++) {
    ctx.fillStyle = COLORS[pixels[i]];
    let r = i - 0x0200;
    let x = r % 32;
    let y = Math.floor(r / 32);
    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }

  ctx.stroke();
};

drawPixel();
renderLoop();
